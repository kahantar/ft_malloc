#import "scalable_malloc.h"
#import "stack_logging.h"
#import "malloc_printf.h"
#import "_simple.h"

/*
 * MALLOC_ABSOLUTE_MAX_SIZE - There are many instances of addition to a
 * user-specified size_t, which can cause overflow (and subsequent crashes)
 * for values near SIZE_T_MAX.  Rather than add extra "if" checks everywhere
 * this occurs, it is easier to just set an absolute maximum request size,
 * and immediately return an error if the requested size exceeds this maximum.
 * Of course, values less than this absolute max can fail later if the value
 * is still too large for the available memory.  The largest value added
 * seems to be PAGE_SIZE (in the macro round_page()), so to be safe, we set
 * the maximum to be 2 * PAGE_SIZE less than SIZE_T_MAX.
 */
#define MALLOC_ABSOLUTE_MAX_SIZE	(SIZE_T_MAX - (2 * PAGE_SIZE))

#define USE_SLEEP_RATHER_THAN_ABORT	0

typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);

__private_extern__ pthread_lock_t _malloc_lock = 0; // initialized in __libc_init

/* The following variables are exported for the benefit of performance tools
 *
 * It should always be safe to first read malloc_num_zones, then read
 * malloc_zones without taking the lock, if only iteration is required
 */
unsigned malloc_num_zones = 0;
unsigned malloc_num_zones_allocated = 0;
malloc_zone_t **malloc_zones = 0;
malloc_logger_t *malloc_logger = NULL;

unsigned malloc_debug_flags = 0;

unsigned malloc_check_start = 0; // 0 means don't check
unsigned malloc_check_counter = 0;
unsigned malloc_check_each = 1000;

/* global flag to suppress ASL logging e.g. for syslogd */
int _malloc_no_asl_log = 0;

static int malloc_check_sleep = 100; // default 100 second sleep
static int malloc_check_abort = 0; // default is to sleep, not abort

static int malloc_debug_file = STDERR_FILENO;
/*
 * State indicated by malloc_def_zone_state
 * 0 - the default zone has not yet been created
 * 1 - a Malloc* environment variable has been set
 * 2 - the default zone has been created and an environment variable scan done
 * 3 - a new default zone has been created and another environment variable scan
 */
__private_extern__ int malloc_def_zone_state = 0;
__private_extern__ malloc_zone_t *__zone0 = NULL;

static const char Malloc_Facility[] = "com.apple.Libsystem.malloc";

#define MALLOC_LOCK()		LOCK(_malloc_lock)
#define MALLOC_UNLOCK()		UNLOCK(_malloc_lock)

#define MALLOC_LOG_TYPE_ALLOCATE	stack_logging_type_alloc
#define MALLOC_LOG_TYPE_DEALLOCATE	stack_logging_type_dealloc
#define MALLOC_LOG_TYPE_HAS_ZONE	stack_logging_flag_zone
#define MALLOC_LOG_TYPE_CLEARED		stack_logging_flag_cleared

/*********	Utilities	************/

static inline malloc_zone_t * find_registered_zone(const void *, size_t *) __attribute__((always_inline));
static inline malloc_zone_t *
find_registered_zone(const void *ptr, size_t *returned_size) {
    // Returns a zone which contains ptr, else NULL
    unsigned index;
    malloc_zone_t	**zones = malloc_zones;
    
    for (index = 0; index < malloc_num_zones; ++index, ++zones) {
        malloc_zone_t *zone = *zones;
        size_t size = zone->size(zone, ptr);
        if (size) { // Claimed by this zone?
            if (returned_size) *returned_size = size;
            return zone;
        }
    }
    // Unclaimed by any zone.
    if (returned_size) *returned_size = 0;
    return NULL;
}

__private_extern__ __attribute__((noinline)) void
malloc_error_break(void) {
	// Provides a non-inlined place for various malloc error procedures to call
	// that will be called after an error message appears.  It does not make
	// sense for developers to call this function, so it is marked
	// __private_extern__ to prevent it from becoming API.
	MAGMALLOC_MALLOCERRORBREAK(); // DTrace USDT probe
}

__private_extern__ boolean_t __stack_logging_locked();

__private_extern__ __attribute__((noinline)) int
malloc_gdb_po_unsafe(void) {
  // In order to implement "po" other data formatters in gdb, the debugger
  // calls functions that call malloc.  The debugger will  only run one thread 
  // of the program in this case, so if another thread is holding a zone lock,
  // gdb may deadlock in this case.
  //
  // Iterate over the zones in malloc_zones, and call "trylock" on the zone 
  // lock.  If trylock succeeds, unlock it, otherwise return "locked".  Returns
  // 0 == safe, 1 == locked/unsafe.
  
  if (__stack_logging_locked())
    return 1;

  malloc_zone_t **zones = malloc_zones;
  unsigned i, e = malloc_num_zones;
  
  for (i = 0; i != e; ++i) {
    malloc_zone_t *zone = zones[i];

    // Version must be >= 5 to look at the new introspection field.
    if (zone->version < 5)
      continue;

    if (zone->introspect->zone_locked && zone->introspect->zone_locked(zone))
      return 1;
  }
  return 0;
}

/*********	Creation and destruction	************/

static void set_flags_from_environment(void);

static void
malloc_zone_register_while_locked(malloc_zone_t *zone) {
    size_t protect_size;
    unsigned i;
    
    /* scan the list of zones, to see if this zone is already registered.  If
     * so, print an error message and return. */
    for (i = 0; i != malloc_num_zones; ++i)
        if (zone == malloc_zones[i]) {
            _malloc_printf(ASL_LEVEL_ERR, "Attempted to register zone more than once: %p\n", zone);
            return;
        }
  
    if (malloc_num_zones == malloc_num_zones_allocated) {
        size_t malloc_zones_size = malloc_num_zones * sizeof(malloc_zone_t *);
        size_t alloc_size = malloc_zones_size + vm_page_size;
        
        malloc_zone_t **new_zones = mmap(0, alloc_size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, VM_MAKE_TAG(VM_MEMORY_MALLOC), 0);
        
        /* If there were previously allocated malloc zones, we need to copy them
         * out of the previous array and into the new zones array */
        if (malloc_zones)
            memcpy(new_zones, malloc_zones, malloc_zones_size);
            
        /* Update the malloc_zones pointer, which we leak if it was previously
         * allocated, and the number of zones allocated */
        protect_size = alloc_size;
        malloc_zones = new_zones;
        malloc_num_zones_allocated = alloc_size / sizeof(malloc_zone_t *);
    } else {
        /* If we don't need to reallocate zones, we need to briefly change the
         * page protection the malloc zones to allow writes */
        protect_size = malloc_num_zones_allocated * sizeof(malloc_zone_t *);
        vm_protect(mach_task_self(), (uintptr_t)malloc_zones, protect_size, 0, VM_PROT_READ | VM_PROT_WRITE);
    }
    malloc_zones[malloc_num_zones++] = zone;
    
    /* Finally, now that the zone is registered, disallow write access to the
     * malloc_zones array */
    vm_protect(mach_task_self(), (uintptr_t)malloc_zones, protect_size, 0, VM_PROT_READ);
    //_malloc_printf(ASL_LEVEL_INFO, "Registered malloc_zone %p in malloc_zones %p [%u zones, %u bytes]\n", zone, malloc_zones, malloc_num_zones, protect_size);
}

static void
_malloc_initialize(void) {
    MALLOC_LOCK();
    if (malloc_def_zone_state < 2) {
	unsigned n;
	malloc_zone_t	*zone;

	malloc_def_zone_state += 2;
	set_flags_from_environment(); // will only set flags up to two times
	n = malloc_num_zones;
	zone = create_scalable_zone(0, malloc_debug_flags);
	malloc_zone_register_while_locked(zone);
	malloc_set_zone_name(zone, "DefaultMallocZone");
	if (n != 0) { // make the default first, for efficiency
		unsigned protect_size = malloc_num_zones_allocated * sizeof(malloc_zone_t *);
		malloc_zone_t *hold = malloc_zones[0];
		if(hold->zone_name && strcmp(hold->zone_name, "DefaultMallocZone") == 0) {
			free((void *)hold->zone_name);
			hold->zone_name = NULL;
		}
		vm_protect(mach_task_self(), (uintptr_t)malloc_zones, protect_size, 0, VM_PROT_READ | VM_PROT_WRITE);
		malloc_zones[0] = malloc_zones[n];
		malloc_zones[n] = hold;
		vm_protect(mach_task_self(), (uintptr_t)malloc_zones, protect_size, 0, VM_PROT_READ);
	}
	// _malloc_printf(ASL_LEVEL_INFO, "%d registered zones\n", malloc_num_zones);
	// _malloc_printf(ASL_LEVEL_INFO, "malloc_zones is at %p; malloc_num_zones is at %p\n", (unsigned)&malloc_zones, (unsigned)&malloc_num_zones);
    }
    MALLOC_UNLOCK();
}

static inline malloc_zone_t *inline_malloc_default_zone(void) __attribute__((always_inline));
static inline malloc_zone_t *
inline_malloc_default_zone(void) {
    if (malloc_def_zone_state < 2) _malloc_initialize();
    // _malloc_printf(ASL_LEVEL_INFO, "In inline_malloc_default_zone with %d %d\n", malloc_num_zones, malloc_has_debug_zone);
    return malloc_zones[0];
}

malloc_zone_t *
malloc_default_zone(void) {
    return inline_malloc_default_zone();
}

malloc_zone_t *
malloc_default_purgeable_zone(void) {
    static malloc_zone_t *dpz;

    if (!dpz) {
        malloc_zone_t *tmp = create_purgeable_zone(0, malloc_default_zone(), malloc_debug_flags);
	malloc_zone_register(tmp);
        malloc_set_zone_name(tmp, "DefaultPurgeableMallocZone");
        if (!__sync_bool_compare_and_swap(&dpz, NULL, tmp))
            malloc_destroy_zone(tmp);
    }
    return dpz;
}

// For debugging, allow stack logging to both memory and disk to compare their results.
static void
stack_logging_log_stack_debug(uint32_t type_flags, uintptr_t zone_ptr, uintptr_t size, uintptr_t ptr_arg, uintptr_t return_val, uint32_t num_hot_to_skip)
{
    __disk_stack_logging_log_stack(type_flags, zone_ptr, size, ptr_arg, return_val, num_hot_to_skip);
    stack_logging_log_stack(type_flags, zone_ptr, size, ptr_arg, return_val, num_hot_to_skip);
}

static void
set_flags_from_environment(void) {
    const char	*flag;
    int		fd;
    char	**env = * _NSGetEnviron();
    char	**p;
    char	*c;

    if (malloc_debug_file != STDERR_FILENO) {
	close(malloc_debug_file);
	malloc_debug_file = STDERR_FILENO;
    }
#if __LP64__
    malloc_debug_flags = SCALABLE_MALLOC_ABORT_ON_CORRUPTION; // Set always on 64-bit processes
#else
    malloc_debug_flags = 0;
#endif
    stack_logging_enable_logging = 0;
    stack_logging_dontcompact = 0;
    malloc_logger = NULL;
    malloc_check_start = 0;
    malloc_check_each = 1000;
    malloc_check_abort = 0;
    malloc_check_sleep = 100;
    /*
     * Given that all environment variables start with "Malloc" we optimize by scanning quickly
     * first the environment, therefore avoiding repeated calls to getenv().
     * If we are setu/gid these flags are ignored to prevent a malicious invoker from changing
     * our behaviour.
     */
    for (p = env; (c = *p) != NULL; ++p) {
	if (!strncmp(c, "Malloc", 6)) {
	    if (issetugid())
		return;
	    break;
	}
    }
    if (c == NULL)
	return;
    flag = getenv("MallocLogFile");
    if (flag) {
	fd = open(flag, O_WRONLY|O_APPEND|O_CREAT, 0644);
	if (fd >= 0) {
           malloc_debug_file = fd;
	   fcntl(fd, F_SETFD, 0); // clear close-on-exec flag  XXX why?
	} else {
	    malloc_printf("Could not open %s, using stderr\n", flag);
	}
    }
    if (getenv("MallocGuardEdges")) {
	malloc_debug_flags = SCALABLE_MALLOC_ADD_GUARD_PAGES;
	_malloc_printf(ASL_LEVEL_INFO, "protecting edges\n");
	if (getenv("MallocDoNotProtectPrelude")) {
	    malloc_debug_flags |= SCALABLE_MALLOC_DONT_PROTECT_PRELUDE;
	    _malloc_printf(ASL_LEVEL_INFO, "... but not protecting prelude guard page\n");
	}
	if (getenv("MallocDoNotProtectPostlude")) {
	    malloc_debug_flags |= SCALABLE_MALLOC_DONT_PROTECT_POSTLUDE;
	    _malloc_printf(ASL_LEVEL_INFO, "... but not protecting postlude guard page\n");
	}
    }
    flag = getenv("MallocStackLogging");
    if (!flag) {
	flag = getenv("MallocStackLoggingNoCompact");
	stack_logging_dontcompact = 1;
    } 
    // For debugging, the MallocStackLogging or MallocStackLoggingNoCompact environment variables can be set to
    // values of "memory", "disk", or "both" to control which stack logging mechanism to use.  Those strings appear
    // in the flag variable, and the strtoul() call below will return 0, so then we can do string comparison on the
    // value of flag.  The default stack logging now is disk stack logging, since memory stack logging is not 64-bit-aware.
    if (flag) {
	unsigned long val = strtoul(flag, NULL, 0);
	if (val == 1) val = 0;
	if (val == -1) val = 0;
	if (val) {
	    malloc_logger = (void *)val;
	    _malloc_printf(ASL_LEVEL_INFO, "recording stacks using recorder %p\n", malloc_logger);
	} else if (strcmp(flag,"memory") == 0) {
	    malloc_logger = (malloc_logger_t *)stack_logging_log_stack;
	    _malloc_printf(ASL_LEVEL_INFO, "recording malloc stacks in memory using standard recorder\n");
	} else if (strcmp(flag,"both") == 0) {
	    malloc_logger = stack_logging_log_stack_debug;
	    _malloc_printf(ASL_LEVEL_INFO, "recording malloc stacks to both memory and disk for comparison debugging\n");
	} else {	// the default is to log to disk
	    malloc_logger = __disk_stack_logging_log_stack;
	    _malloc_printf(ASL_LEVEL_INFO, "recording malloc stacks to disk using standard recorder\n");
	}
	stack_logging_enable_logging = 1;
	if (stack_logging_dontcompact) {
	    if (malloc_logger == __disk_stack_logging_log_stack) {
	      _malloc_printf(ASL_LEVEL_INFO, "stack logging compaction turned off; size of log files on disk can increase rapidly\n");
	    } else {
	      _malloc_printf(ASL_LEVEL_INFO, "stack logging compaction turned off; VM can increase rapidly\n");
	    }
	}
    }
    if (getenv("MallocScribble")) {
        malloc_debug_flags |= SCALABLE_MALLOC_DO_SCRIBBLE;
        _malloc_printf(ASL_LEVEL_INFO, "enabling scribbling to detect mods to free blocks\n");
    }
    if (getenv("MallocErrorAbort")) {
        malloc_debug_flags |= SCALABLE_MALLOC_ABORT_ON_ERROR;
        _malloc_printf(ASL_LEVEL_INFO, "enabling abort() on bad malloc or free\n");
    }
#if __LP64__
    /* initialization above forces SCALABLE_MALLOC_ABORT_ON_CORRUPTION of 64-bit processes */
#else
    if (getenv("MallocCorruptionAbort")) { // Set from an environment variable in 32-bit processes
	malloc_debug_flags |= SCALABLE_MALLOC_ABORT_ON_CORRUPTION;
    }
#endif
    flag = getenv("MallocCheckHeapStart");
    if (flag) {
	malloc_check_start = strtoul(flag, NULL, 0);
	if (malloc_check_start == 0) malloc_check_start = 1;
	if (malloc_check_start == -1) malloc_check_start = 1;
	flag = getenv("MallocCheckHeapEach");
	if (flag) {
	    malloc_check_each = strtoul(flag, NULL, 0);
	    if (malloc_check_each == 0) malloc_check_each = 1;
	    if (malloc_check_each == -1) malloc_check_each = 1;
	}
	_malloc_printf(ASL_LEVEL_INFO, "checks heap after %dth operation and each %d operations\n", malloc_check_start, malloc_check_each);
	flag = getenv("MallocCheckHeapAbort");
	if (flag)
	    malloc_check_abort = strtol(flag, NULL, 0);
	if (malloc_check_abort)